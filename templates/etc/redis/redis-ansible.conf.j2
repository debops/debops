# {{ ansible_managed }}

{% set redis_tpl_redis_version = register_redis_version.stdout | replace('v=', '') -%}
{#    UNITS
      # When memory size is needed, it is possible to specify
      # it in the usual form of 1k 5GB 4M and so forth:
      #
      # 1k  => 1000 bytes
      # 1kb => 1024 bytes
      # 1m  => 1000000 bytes
      # 1mb => 1024*1024 bytes
      # 1g  => 1000000000 bytes
      # 1gb => 1024*1024*1024 bytes #}

###############################  GENERAL  #####################################

daemonize {{ redis_daemonize }}
pidfile "{{ redis_pidfile }}"
port {{ redis_port }}
{% if redis_tpl_redis_version | version_compare('2.8.5', '>=') -%}
tcp-backlog {{ redis_tcp_backlog }}
{% endif -%}
bind {{ redis_bind | join(' ') }}
timeout {{ redis_timeout }}
tcp-keepalive {{ redis_tcp_keepalive }}
loglevel {{ redis_loglevel }}
logfile {{ redis_logfile }}
syslog-ident "{{ redis_syslog_ident }}"
databases {{ redis_databases }}

###############################  SNAPSHOTTING  ################################

stop-writes-on-bgsave-error {{ redis_stop_writes_on_bgsave_error }}
rdbcompression {{ redis_rdbcompression }}
rdbchecksum {{ redis_rdbchecksum }}
dbfilename "{{ redis_dbfilename }}"
dir "{{ redis_dir }}"

################################# REPLICATION #################################

{% if redis_requirepass -%}
masterauth {{ redis_requirepass }}
{% endif -%}
slave-serve-stale-data {{ redis_slave_serve_stale_data }}
slave-read-only {{ redis_slave_read_only }}
repl-ping-slave-period {{ redis_repl_ping_slave_period }}
repl-timeout {{ redis_repl_timeout }}
repl-disable-tcp-nodelay {{ redis_repl_disable_tcp_nodelay }}
repl-backlog-size {{ redis_repl_backlog_size }}
repl-backlog-ttl {{ redis_repl_backlog_ttl }}
slave-priority {{ redis_slave_priority }}
min-slaves-to-write {{ redis_min_slaves_to_write }}
min-slaves-max-lag {{ redis_min_slaves_max_lag }}

################################## SECURITY ###################################

{% if redis_requirepass -%}
requirepass {{ redis_requirepass }}
{% endif -%}

################################### LIMITS ####################################

maxmemory-policy {{ redis_maxmemory_policy }}
maxmemory-samples {{ redis_maxmemory_samples }}

############################## APPEND ONLY MODE ###############################

appendonly no
appendfilename "{{ redis_appendfilename }}"
appendfsync {{ redis_appendfsync }}
no-appendfsync-on-rewrite {{ redis_no_appendfsync_on_rewrite }}
auto-aof-rewrite-percentage {{ redis_auto_aof_rewrite_percentage }}
auto-aof-rewrite-min-size {{ redis_auto_aof_rewrite_min_size }}

################################ LUA SCRIPTING  ###############################

lua-time-limit {{ redis_lua_time_limit }}

################################## SLOW LOG ###################################

slowlog-log-slower-than {{ redis_slowlog_log_slower_than }}
slowlog-max-len {{ redis_slowlog_max_len }}

################################ LATENCY MONITOR ##############################

{% if redis_tpl_redis_version | version_compare('2.8.13', '>=') -%}
latency-monitor-threshold {{ redis_latency_monitor_threshold }}
{% endif -%}

############################# EVENT NOTIFICATION ##############################

{% if redis_notify_keyspace_events -%}
notify-keyspace-events {{ redis_notify_keyspace_events}}
{% endif -%}

############################### ADVANCED CONFIG ###############################

# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Similarly to hashes, small lists are also encoded in a special way in order
# to save a lot of space. The special representation is only used when
# you are under the following limits:
list-max-ziplist-entries 512
list-max-ziplist-value 64

# Sets have a special encoding in just one case: when a set is composed
# of just strings that happens to be integers in radix 10 in the range
# of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
{% if redis_tpl_redis_version | version_compare('2.8.9', '>=') -%}
hll-sparse-max-bytes 3000
{% endif -%}

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operation you run into a hash table
# that is rehashing, the more rehashing "steps" are performed, so if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
#
# The default is to use this millisecond 10 times every second in order to
# active rehashing the main dictionaries, freeing memory when possible.
#
# If unsure:
# use "activerehashing no" if you have hard latency requirements and it is
# not a good thing in your environment that Redis can reply form time to time
# to queries with 2 milliseconds delay.
#
# use "activerehashing yes" if you don't have such hard requirements but
# want to free memory asap when possible.
activerehashing yes

# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
#
# The limit can be set differently for the three different classes of clients:
#
# normal -> normal clients including MONITOR clients
# slave  -> slave clients
# pubsub -> clients subscribed to at least one pubsub channel or pattern
#
# The syntax of every client-output-buffer-limit directive is the following:
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# A client is immediately disconnected once the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (continuously).
# So for instance if the hard limit is 32 megabytes and the soft limit is
# 16 megabytes / 10 seconds, the client will get disconnected immediately
# if the size of the output buffers reach 32 megabytes, but will also get
# disconnected if the client reaches 16 megabytes and continuously overcomes
# the limit for 10 seconds.
#
# By default normal clients are not limited because they don't receive data
# without asking (in a push way), but just after a request, so only
# asynchronous clients may create a scenario where data is requested faster
# than it can read.
#
# Instead there is a default limit for pubsub and slave clients, since
# subscribers and slaves receive data in a push fashion.
#
# Both the hard or the soft limit can be disabled by setting them to zero.
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys that are
# never requested, and so forth.
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform accordingly to the specified "hz" value.
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
hz 10

# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
aof-rewrite-incremental-fsync yes
